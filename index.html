<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Dorita ❤️</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
</head>
<body>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: linear-gradient(180deg, #0a0015 0%, #1a0520 50%, #2a0a30 100%);
            font-family: 'Dancing Script', cursive;
            color: #fff;
            transition: background 1.5s ease;
        }
        #container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden;
        }
        .glow {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; mix-blend-mode: screen; opacity: 0.6;
            background: radial-gradient(circle at 50% 50%, rgba(255, 105, 180, 0.15) 0%, rgba(255, 20, 147, 0.1) 40%, transparent 70%);
        }

        /* Mensaje romántico */
        #romantic-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 2s ease;
            max-width: 90%;
        }
        #romantic-message.show {
            opacity: 1;
        }
        #romantic-message h1 {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(2rem, 8vw, 6rem);
            color: #ff69b4;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.8),
                         0 0 40px rgba(255, 105, 180, 0.6),
                         0 0 60px rgba(255, 105, 180, 0.4);
            margin-bottom: 20px;
            animation: heartbeat 2s ease-in-out infinite;
        }
        #romantic-message p {
            font-size: clamp(1rem, 3vw, 1.8rem);
            color: #ffd1dc;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
            line-height: 1.8;
            margin: 15px 0;
        }
        #romantic-message .signature {
            font-size: clamp(1.2rem, 4vw, 2.5rem);
            color: #ff1493;
            margin-top: 30px;
            font-weight: bold;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            10% { transform: scale(1.05); }
            20% { transform: scale(1); }
            30% { transform: scale(1.05); }
            40% { transform: scale(1); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }

        /* Controles UI */
        .ui-panel {
            position: fixed;
            z-index: 100;
            padding: 12px 20px;
            border: 1px solid rgba(255, 105, 180, 0.4);
            border-radius: 16px;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            background: rgba(58, 20, 60, 0.3);
            box-shadow: 0 4px 30px rgba(255, 105, 180, 0.2);
            transition: all 0.3s ease;
        }

        #ui-bottom-right {
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: flex-end;
        }

        .theme-btn {
            padding: 10px 24px;
            border: 1px solid rgba(255, 105, 180, 0.4);
            background: rgba(255, 105, 180, 0.2);
            color: #fff;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            font-family: 'Dancing Script', cursive;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.3);
        }
        .theme-btn:hover {
            background: rgba(255, 105, 180, 0.4);
            border-color: rgba(255, 105, 180, 0.7);
            box-shadow: 0 0 25px rgba(255, 105, 180, 0.5);
            transform: translateY(-2px);
        }
        .theme-btn:active {
            transform: translateY(0);
        }

        /* Corazones flotantes de fondo */
        .floating-heart {
            position: fixed;
            font-size: 20px;
            opacity: 0.6;
            pointer-events: none;
            animation: floatUp 15s linear infinite;
            z-index: 1;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 0.6;
            }
            90% {
                opacity: 0.6;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .ui-panel { padding: 10px 16px; }
            #ui-bottom-right { bottom: 15px; right: 15px; }
            .theme-btn { padding: 8px 18px; font-size: 14px; }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
            }
        }
    </script>

    <div id="container"></div>
    <div class="glow"></div>

    <!-- Mensaje romántico -->
    <div id="romantic-message">
        <h1>Dorita</h1>
        <p>En cada latido de mi corazón,</p>
        <p>en cada estrella que brilla en el cielo,</p>
        <p>existe un recordatorio de cuánto te amo.</p>
        <p style="margin-top: 30px; font-size: clamp(1.2rem, 4vw, 2.2rem); color: #ff69b4;">
            Lo siento con todo mi corazón
        </p>
        <p>Perdóname por haberte lastimado.</p>
        <p>Eres mi todo, mi luz, mi amor.</p>
        <p class="signature">Te amo infinitamente ❤️</p>
    </div>

    <!-- Controles -->
    <div id="ui-bottom-right" class="ui-panel">
        <button id="pulseBtn" class="theme-btn">💕 Pulso de Amor</button>
        <button id="messageBtn" class="theme-btn">💌 Ver Mensaje</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, particles, composer, controls;
        let time = 0;
        let particleCount = 15000;
        let shockwaves = [];
        let currentShape = 0; // 0: corazón, 1: DORITA, 2: LO SIENTO, 3: corazón grande
        let transitionProgress = 0;
        let isTransitioning = false;
        const SHAPE_DURATION = 8; // segundos en cada forma
        const TRANSITION_DURATION = 3; // segundos de transición

        // Formas disponibles
        const shapes = {
            heart: 0,
            dorita: 1,
            loSiento: 2,
            heartBig: 3
        };

        // Crear corazones flotantes de fondo
        function createFloatingHearts() {
            const hearts = ['❤️', '💕', '💖', '💗', '💝', '💓', '💞'];
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.className = 'floating-heart';
                    heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
                    heart.style.left = Math.random() * 100 + '%';
                    heart.style.animationDelay = Math.random() * 15 + 's';
                    heart.style.animationDuration = (15 + Math.random() * 10) + 's';
                    document.body.appendChild(heart);
                }, i * 500);
            }
        }

        // Función para crear forma de corazón
        function createHeartShape(t, scale = 2.0) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return new THREE.Vector2(x * scale, -y * scale);
        }

        // Función para crear letras del texto
        function createTextShape(particleIndex, totalParticles, text, scale = 1.0) {
            const letterShapes = {
                'D': [
                    [0,0], [0,1], [0,2], [0,3], [0,4],
                    [1,0], [2,0], [3,1], [3,2], [3,3], [2,4], [1,4]
                ],
                'O': [
                    [1,0], [2,0], [3,0],
                    [0,1], [4,1],
                    [0,2], [4,2],
                    [0,3], [4,3],
                    [1,4], [2,4], [3,4]
                ],
                'R': [
                    [0,0], [0,1], [0,2], [0,3], [0,4],
                    [1,0], [2,0], [3,1],
                    [1,2], [2,2],
                    [3,3], [3,4]
                ],
                'I': [
                    [0,0], [1,0], [2,0],
                    [1,1], [1,2], [1,3],
                    [0,4], [1,4], [2,4]
                ],
                'T': [
                    [0,0], [1,0], [2,0], [3,0], [4,0],
                    [2,1], [2,2], [2,3], [2,4]
                ],
                'A': [
                    [2,0],
                    [1,1], [3,1],
                    [0,2], [4,2],
                    [0,3], [1,3], [2,3], [3,3], [4,3],
                    [0,4], [4,4]
                ],
                'L': [
                    [0,0], [0,1], [0,2], [0,3], [0,4],
                    [1,4], [2,4], [3,4]
                ],
                'S': [
                    [1,0], [2,0], [3,0],
                    [0,1], [1,2], [2,2],
                    [3,3], [0,4], [1,4], [2,4]
                ]
            };

            // Construir el texto completo
            let allPoints = [];
            let offsetX = 0;
            const letterSpacing = 6;

            for (let char of text) {
                if (letterShapes[char]) {
                    const points = letterShapes[char].map(p => [p[0] + offsetX, p[1]]);
                    allPoints.push(...points);
                    offsetX += letterSpacing;
                }
            }

            if (allPoints.length === 0) return new THREE.Vector2(0, 0);

            // Distribuir partículas entre todos los puntos
            const pointsPerPixel = Math.ceil(totalParticles / allPoints.length);
            const pointIndex = Math.floor(particleIndex / pointsPerPixel) % allPoints.length;
            const point = allPoints[pointIndex];

            // Centrar el texto
            const centerX = offsetX / 2;
            const centerY = 2.5;

            // Añadir jitter para rellenar
            const jitter = (particleIndex % pointsPerPixel) / pointsPerPixel;
            const jitterX = (Math.random() - 0.5) * 0.8;
            const jitterY = (Math.random() - 0.5) * 0.8;

            return new THREE.Vector2(
                (point[0] - centerX) * scale * 3 + jitterX,
                (point[1] - centerY) * scale * 3 + jitterY
            );
        }

        // Función principal para obtener posición según la forma actual
        function getShapePosition(particleIndex, totalParticles, shapeType) {
            const t = (particleIndex / totalParticles) * Math.PI * 2;
            const z = Math.sin(t * 3) * 3;

            let pos2D;
            switch(shapeType) {
                case shapes.heart:
                    pos2D = createHeartShape(t, 2.0);
                    break;
                case shapes.dorita:
                    pos2D = createTextShape(particleIndex, totalParticles, 'DORITA', 1.2);
                    break;
                case shapes.loSiento:
                    pos2D = createTextShape(particleIndex, totalParticles, 'LO SIENTO', 0.8);
                    break;
                case shapes.heartBig:
                    pos2D = createHeartShape(t, 2.8);
                    break;
                default:
                    pos2D = createHeartShape(t, 2.0);
            }

            return new THREE.Vector3(pos2D.x, pos2D.y, z);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1500);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.rotateSpeed = 0.5;
            controls.minDistance = 30;
            controls.maxDistance = 300;
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // Post-processing con bloom romántico
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));

            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.8, // strength - más intenso para efecto romántico
                0.6, // radius
                0.3  // threshold - más bajo para más brillo
            );
            composer.addPass(bloomPass);
            composer.addPass(new OutputPass());

            createParticleSystem();
            createFloatingHearts();

            window.addEventListener('resize', onWindowResize);

            // Botón de pulso
            document.getElementById('pulseBtn').addEventListener('click', () => {
                triggerShockwave({ amplitude: 15, speed: 25, width: 8, decay: 1.0 });
            });

            // Botón de mensaje
            let messageShown = false;
            document.getElementById('messageBtn').addEventListener('click', () => {
                const msg = document.getElementById('romantic-message');
                messageShown = !messageShown;
                if (messageShown) {
                    msg.classList.add('show');
                } else {
                    msg.classList.remove('show');
                }
            });

            // Auto-mostrar mensaje al inicio después de 3 segundos
            setTimeout(() => {
                document.getElementById('romantic-message').classList.add('show');
                setTimeout(() => {
                    document.getElementById('romantic-message').classList.remove('show');
                }, 10000); // Mostrar por 10 segundos
            }, 3000);

            animate();
        }

        function createParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const targetPositions = new Float32Array(particleCount * 3);
            const nextTargetPositions = new Float32Array(particleCount * 3);

            // Colores románticos: rosa, rojo, dorado
            const romanticColors = [
                new THREE.Color(0xff69b4), // Hot pink
                new THREE.Color(0xff1493), // Deep pink
                new THREE.Color(0xff6b9d), // Rosa pastel
                new THREE.Color(0xffc0cb), // Pink
                new THREE.Color(0xffb6c1), // Light pink
                new THREE.Color(0xff69b4), // Hot pink
                new THREE.Color(0xffd700), // Gold
                new THREE.Color(0xff8c94), // Rosa coral
            ];

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // Posición inicial (corazón)
                const pos = getShapePosition(i, particleCount, shapes.heart);
                positions[i3] = pos.x;
                positions[i3 + 1] = pos.y;
                positions[i3 + 2] = pos.z;

                targetPositions[i3] = pos.x;
                targetPositions[i3 + 1] = pos.y;
                targetPositions[i3 + 2] = pos.z;

                nextTargetPositions[i3] = pos.x;
                nextTargetPositions[i3 + 1] = pos.y;
                nextTargetPositions[i3 + 2] = pos.z;

                // Colores románticos
                const colorIndex = Math.floor((i / particleCount) * romanticColors.length);
                const color = romanticColors[colorIndex].clone();
                const brightness = 0.7 + Math.random() * 0.3;

                colors[i3] = color.r * brightness;
                colors[i3 + 1] = color.g * brightness;
                colors[i3 + 2] = color.b * brightness;

                sizes[i] = 0.8 + Math.random() * 0.6;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
            geometry.setAttribute('nextTargetPosition', new THREE.BufferAttribute(nextTargetPositions, 3));

            const texture = createParticleTexture();
            const material = new THREE.PointsMaterial({
                size: 3.5,
                map: texture,
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
                alphaTest: 0.01
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            const size = 64;
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const centerX = size / 2, centerY = size / 2;
            const radius = size * 0.45;

            // Gradiente romántico con brillo en el centro
            const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,220,230,0.9)');
            gradient.addColorStop(0.5, 'rgba(255,180,200,0.6)');
            gradient.addColorStop(1, 'rgba(255,105,180,0)');

            context.beginPath();
            context.arc(centerX, centerY, radius, 0, Math.PI * 2);
            context.fillStyle = gradient;
            context.fill();

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function triggerShockwave({ amplitude = 15, speed = 25, width = 8, decay = 1.0 } = {}) {
            shockwaves.push({ t0: time, amplitude, speed, width, decay });
            if (shockwaves.length > 5) shockwaves.shift();
        }

        function updateShapeTransition() {
            const cycleTime = SHAPE_DURATION + TRANSITION_DURATION;
            const timeInCycle = (time * 0.5) % cycleTime;

            let newShape = currentShape;
            let newIsTransitioning = false;
            let newProgress = 0;

            if (timeInCycle < SHAPE_DURATION) {
                // Mantener forma actual
                newIsTransitioning = false;
                newProgress = 0;
            } else {
                // Transición a siguiente forma
                newIsTransitioning = true;
                newProgress = (timeInCycle - SHAPE_DURATION) / TRANSITION_DURATION;

                if (!isTransitioning) {
                    // Cambiar a siguiente forma
                    newShape = (currentShape + 1) % 4;

                    // Actualizar nextTargetPositions
                    const nextTargets = particles.geometry.attributes.nextTargetPosition.array;
                    for (let i = 0; i < particleCount; i++) {
                        const pos = getShapePosition(i, particleCount, newShape);
                        nextTargets[i * 3] = pos.x;
                        nextTargets[i * 3 + 1] = pos.y;
                        nextTargets[i * 3 + 2] = pos.z;
                    }
                    particles.geometry.attributes.nextTargetPosition.needsUpdate = true;
                }
            }

            currentShape = newShape;
            isTransitioning = newIsTransitioning;
            transitionProgress = newProgress;
        }

        function animateParticles() {
            if (!particles) return;

            updateShapeTransition();

            const positions = particles.geometry.attributes.position.array;
            const targetPositions = particles.geometry.attributes.targetPosition.array;
            const nextTargetPositions = particles.geometry.attributes.nextTargetPosition.array;
            const colors = particles.geometry.attributes.color.array;
            const sizes = particles.geometry.attributes.size.array;

            // Colores románticos que cambian
            const romanticColors = [
                new THREE.Color(0xff69b4),
                new THREE.Color(0xff1493),
                new THREE.Color(0xff6b9d),
                new THREE.Color(0xffc0cb),
                new THREE.Color(0xffb6c1),
                new THREE.Color(0xff69b4),
                new THREE.Color(0xffd700),
                new THREE.Color(0xff8c94),
            ];

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                let targetX, targetY, targetZ;

                if (isTransitioning) {
                    // Interpolación suave entre formas
                    const easeProgress = transitionProgress < 0.5
                        ? 2 * transitionProgress * transitionProgress
                        : 1 - Math.pow(-2 * transitionProgress + 2, 2) / 2;

                    targetX = THREE.MathUtils.lerp(targetPositions[i3], nextTargetPositions[i3], easeProgress);
                    targetY = THREE.MathUtils.lerp(targetPositions[i3 + 1], nextTargetPositions[i3 + 1], easeProgress);
                    targetZ = THREE.MathUtils.lerp(targetPositions[i3 + 2], nextTargetPositions[i3 + 2], easeProgress);

                    if (transitionProgress > 0.99) {
                        targetPositions[i3] = nextTargetPositions[i3];
                        targetPositions[i3 + 1] = nextTargetPositions[i3 + 1];
                        targetPositions[i3 + 2] = nextTargetPositions[i3 + 2];
                    }
                } else {
                    targetX = targetPositions[i3];
                    targetY = targetPositions[i3 + 1];
                    targetZ = targetPositions[i3 + 2];
                }

                // Aplicar ondas de choque
                const dist = Math.sqrt(targetX * targetX + targetY * targetY + targetZ * targetZ) + 1e-6;
                let addX = 0, addY = 0, addZ = 0;

                for (let w = 0; w < shockwaves.length; w++) {
                    const sw = shockwaves[w];
                    const elapsed = Math.max(0, time - sw.t0);
                    const R = sw.speed * elapsed;
                    const sigma = sw.width;
                    const decayFactor = Math.exp(-sw.decay * elapsed);
                    const g = Math.exp(-((dist - R) * (dist - R)) / (2 * sigma * sigma));
                    const amp = sw.amplitude * g * decayFactor;

                    addX += (targetX / dist) * amp;
                    addY += (targetY / dist) * amp;
                    addZ += (targetZ / dist) * amp * 0.3;
                }

                const finalTargetX = targetX + addX;
                const finalTargetY = targetY + addY;
                const finalTargetZ = targetZ + addZ;

                // Movimiento suave hacia el objetivo
                const lerpFactor = 0.05;
                positions[i3] += (finalTargetX - positions[i3]) * lerpFactor;
                positions[i3 + 1] += (finalTargetY - positions[i3 + 1]) * lerpFactor;
                positions[i3 + 2] += (finalTargetZ - positions[i3 + 2]) * lerpFactor;

                // Colores románticos pulsantes
                const colorIndex = Math.floor((i / particleCount) * romanticColors.length);
                const color = romanticColors[colorIndex];
                const pulse = 0.7 + Math.sin(time * 2 + i * 0.1) * 0.3;
                const twinkle = 0.9 + Math.sin(time * 5 + i * 0.5) * 0.1;

                colors[i3] = color.r * pulse * twinkle;
                colors[i3 + 1] = color.g * pulse * twinkle;
                colors[i3 + 2] = color.b * pulse * twinkle;

                // Tamaños pulsantes
                const sizePulse = 0.9 + Math.sin(time * 3 + i * 0.2) * 0.1;
                sizes[i] = (0.8 + Math.random() * 0.4) * sizePulse;
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            particles.geometry.attributes.size.needsUpdate = true;

            // Limpiar ondas antiguas
            if (shockwaves.length > 0) {
                shockwaves = shockwaves.filter(sw => {
                    const elapsed = time - sw.t0;
                    return elapsed < 10;
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016; // ~60fps

            controls.update();
            animateParticles();
            composer.render();
        }

        // Iniciar cuando el DOM esté listo
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
